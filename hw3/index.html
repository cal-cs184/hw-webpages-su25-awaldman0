<html>
	<head>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=default'></script>
		<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
		<style>
			h1 {
				text-align: center;
			}

			.container {
				margin: 0 auto;
				padding: 60px 20%;
			}

			figure {
				text-align: center;
			}

			img {
				display: inline-block;
			}

			body {
				font-family: 'Inter', sans-serif;
			}
		</style>
	</head>
	<body>
		<div class="container">
			<h1>CS184/284A Spring 2025 Homework 3 Write-Up</h1>
			<div style="text-align: center;">Name: Alexander Waldman </div>

			<br>

			Link to webpage: <a href="https://cal-cs184.github.io/hw-webpages-su25-awaldman0/hw3/index.html">cal-cs184.github.io/hw-webpages-su25-awaldman0/hw3/index.html</a>

			<br>

			Link to GitHub repository: <a href="https://github.com/cal-cs184/hw-pathtracer-updated-tomatoes">github.com/cal-cs184/hw-pathtracer-updated-tomatoes</a>

			<!--
	We've already added one heading per part, to make your write-up as navigable when grading. Please fit your write-up within these sections!
	-->

			<h2>Overview</h2>
			Give a high-level overview of what you implemented in this homework. Think about what you've built as a whole. Share your thoughts on what interesting things you've learned from completing the homework.

			<h2>Part 1: Ray Generation and Scene Intersection</h2>
			<p>When ray tracing a scene, one must first generate rays to send out from the camera. When these rays collide with geometry, they can be used to calculate a variety of useful data points, including surface normals at the point of intersection and how much light is being emitted/reflected towards the camera. When generating rays, it's crucial to properly convert between camera space and world space to ensure that 1) the origin of each ray is actually within the boundaries of the current pixel we want to raytrace and 2) rays are being properly sent towards the scene (where all of the geometry is) instead of shooting off into an empty section of world space. I handled the logic for this section of part 1 in <code>Camera::generate_ray()</code>. Once rays are sent out from the camera, the next step in the core rendering pipeline is to check for intersections between each ray and the primitives in the scene. As mentioned previously, this step is incredibly important because it allows us to actually engage with the properties of the materials/primitives, which is how ray/path tracing is able to accurately light a scene.</p>
			<p>I had a few options when it came to choosing an approach for calculating ray-triangle intersection. The first and simplest approach would be to use a point on the triangle and one of its normals to first test if the ray intersect with the plane the triangle lies on. If so, one can then use the <code>t</code> value at the intersection point to derive the coordinates of the intersection in world space. From there, you can do point-in-triangle tests (much like we did in Homework 1) to determine if the ray collides with a triangle. The second approach is to implement the Moller Trumbore Algorithm for ray-triangle intersection presented in lecture. I chose to go with Moller Trumbore for a few reasons, the main one being speed. Compared to the first approach, Moller Trumbore involves fewer division, multiplication, and addition operations. When tracing billions of rays for a single scene, these small optimizations add up. The second main reason for using this algorithm is it derives barycentric coordinates in addition to the <code>t</code> value corresponding to the intersection point on the plane. From there, it's easy to verify if the intersection lie within the triangle by checking if the barycentric coordinates are non-negative. Having barycentric coordinates also allows us to very easily interpolate between the triangles vertex normals, which are crucial for smooth shading. Had I chosen to use a different strategy for ray-triangle intersection, finding barycentric coordinates in 3D would prove to be a more difficult and computationally expensive task. I implemented Moller Trumbore in <code>Triangle::intersect</code> and <code>Triangle::has_intersection</code> as presented in lecture, perfroming a few additional checks to ensure the intersection point is located at a valid place along the ray. With basic ray-primitive intersection in place, I rendered the following images with normal shading.</p>
			<div style="display: flex; flex-direction: column; align-items: center;">
				<table style="width: 100%; text-align: center; border-collapse: collapse;">
					<tr>
						<td style="text-align: center;">
							<img src="images/part1_1.png" width="400px" />
							<figcaption>dae/sky/CBgems.dae</figcaption>
						</td>
						<td style="text-align: center;">
							<img src="images/part1_2.png" width="400px" />
							<figcaption>dae/sky/CBcoil.dae</figcaption>
						</td>
					</tr>
					<tr>
						<td style="text-align: center;">
							<img src="images/part1_3.png" width="400px" />
							<figcaption>dae/meshedit/teapot.dae</figcaption>
						</td>
						<td style="text-align: center;">
							<img src="images/part1_4.png" width="400px" />
							<figcaption>dae/keenan/banana.dae</figcaption>
						</td>
					</tr>
				</table>
			</div>

			<h2>Part 2: Bounding Volume Hierarchy</h2>
			<p>While ray intersection works fine for simple scenes with very little geometry, each intersection test iterates through every single primitive in order to determine if an intersection takes place, which is highly inefficient. This makes it all but impossible to render scenes with high polygon counts. One way to improve the performance of intersection tests is to partition 3D space with a Bounding Volume Hierarchy (BVH), a tree data structure that helps us only perfrom intersection tests in areas that a ray is actually traveling through. In order to improve the performance of my renderer for complicated scenes, I constucted a BVH in <code>BVHAccel::construct_bvh()</code>, which works as follows:</p>
			<ol>
				<li>Iterate between <code>start</code> and <code>end</code>, expanding <code>bbox</code> to include every primitive in the list. As you're iterating, increment a variable <code>size</code> to keep track of how many primitive are in the current node.</li>
				<li>If <code>size <= max_leaf_size</code>, create a leaf node by setting <code>node->start = start</code>, <code>node->end = end</code>, <code>node->l = NULL</code>, and <code>node->r = NULL</code></li>.
				<li>If not, calculate the longest axis by finding <code>max(bbox.extent.x, max(bbox.extent.y, bbox.extent.z))</code>. From there, sort primitives bewteen <code>start</code> and <code>end</code> by their centroids along chosen axis. For example, if the x axis is the logest axis, call
<pre>
<code>
	if (largest_extent == bbox.extent.x) {
		sort(start, end, [](Primitive* a, Primitive* b) {
			return a->get_bbox().centroid().x < b->get_bbox().centroid().x; });
	}
</code>
</pre>
				
				</li>
				<li>From there, split around the median primitive and recursively call <code>construct_bvh()</code> by setting <code>node->l = construct_bvh(start, start + (size / 2), max_leaf_size)</code> and <code>node->r = construct_bvh(start + (size / 2), end, max_leaf_size)</code></li>
			</ol>
			<p>When it came to my splitting heuristic, I wanted to ensure that the BVH was as balanced as possible, meaning traversing the tree would be efficient regardless of the ray's direction in 3D space. Splitting along the longest axis helps ensure that primitives stored in leaf nodes will also be close to each other in world space. This means that if a ray intersects the bounding box of a leaf node, it has a high liklihood of intersecting one of the polugons stored there. If I deciced to, say,  split along the x axis every time, I could very well end up with leaf nodes containing primitives that are very far away from each other on the x and y axes, leading to sparsely populated bounding boxes where a ray is unlikely to intersect with a primitive even when it intersects the bounding box. Additionally, the choice to split along the median primitive instead of something like the average was done to keep the tree balanced. With BVH construction/traversal implemented in my renderer, I could now render very large .dae files with normal shading very quickly.</p>
			<div style="display: flex; flex-direction: column; align-items: center;">
				<table style="width: 100%; text-align: center; border-collapse: collapse;">
					<tr>
						<td style="text-align: center;">
							<img src="images/part2_1.png" width="400px" />
							<figcaption>64,618 primitives, 0.0728 seconds to render</figcaption>
						</td>
						<td style="text-align: center;">
							<img src="images/part2_2.png" width="400px" />
							<figcaption>100,012 primitives, 0.1625 seconds to render</figcaption>
						</td>
					</tr>
					<tr>
						<td style="text-align: center;">
							<img src="images/part2_3.png" width="400px" />
							<figcaption>196,608 primitives, 0.1698 seconds to render</figcaption>
						</td>
						<td style="text-align: center;">
							<img src="images/part2_4.png" width="400px" />
							<figcaption>240,326 primitives, 0.1948 seconds to render</figcaption>
						</td>
					</tr>
				</table>
			</div>
			<p>To explore how much a BVH improves rendering performance, I examined rendering times for three moderately complex .dae files with and without BVH acceleration to see how they compare. For each .dae file, I rendered an image at 800x600 resolution with and without BVH acceleration three times to get a sense for the average performance. For meshedit/cow.dae (5856 primitives), I could render an image in about 0.089 seconds with BVH acceleration and about 25.87 seconds without BVH acceleration. For sky/CBcoil.dae (7884 primitives), I could render an image in about 0.10 seconds with BVH acceleration and about 45.53 seconds without BVH acceleration. Lastly, for meshedit/beetle.dae (7558 primitives), I could render an image in about 0.079 seconds with BVH acceleration and about 38.71 seconds without BVH acceleration. Across those 3 files, I saw an average speedup of about 412x. You'll notice that having fewer primitives does not always mean something will render faster with BVH, as meshedit/beetle.dae rendered faster than meshedit/cow.dae despite having 1702 more primitives. I imagine this has something to do with the density of polygons in the mesh, although I cannot say for sure. Regardless, we can see that BVH acceleration affords us the ability to render extremely complicated scenes very quickly, and will serve a crucial role later on as renders become increasingly computationally expensive.</p>

			<h2>Part 3: Direct Illumination</h2>
			64 of samples per pixel, 32 samples per light
			<div style="display: flex; flex-direction: column; align-items: center;">
				<table style="width: 100%; text-align: center; border-collapse: collapse;">
					<tr>
						<td style="text-align: center;">
							<img src="images/part3_1.png" width="400px" />
							<figcaption>Uniform Hemisphere Sampling</figcaption>
						</td>
						<td style="text-align: center;">
							<img src="images/part3_2.png" width="400px" />
							<figcaption>Light Sampling</figcaption>
						</td>
					</tr>
					<tr>
						<td style="text-align: center;">
							<img src="images/part3_3.png" width="400px" />
							<figcaption>Uniform Hemisphere Sampling</figcaption>
						</td>
						<td style="text-align: center;">
							<img src="images/part3_4.png" width="400px" />
							<figcaption>Light Sampling</figcaption>
						</td>
					</tr>
					<tr>
						<td style="text-align: center;">
							<img src="images/part3_5.png" width="400px" />
							<figcaption>Uniform Hemisphere Sampling</figcaption>
						</td>
						<td style="text-align: center;">
							<img src="images/part3_6.png" width="400px" />
							<figcaption>Light Sampling</figcaption>
						</td>
					</tr>
				</table>
			</div>
			dae/sky/dragon.dae with 1 sample per pixel and different number of light rays per pixel
			<div style="display: flex; flex-direction: column; align-items: center;">
				<table style="width: 100%; text-align: center; border-collapse: collapse;">
					<tr>
						<td style="text-align: center;">
							<img src="images/part3_7.png" width="400px" />
							<figcaption>1 light ray</figcaption>
						</td>
						<td style="text-align: center;">
							<img src="images/part3_8.png" width="400px" />
							<figcaption>4 light rays</figcaption>
						</td>
					</tr>
					<tr>
						<td style="text-align: center;">
							<img src="images/part3_9.png" width="400px" />
							<figcaption>16 light rays</figcaption>
						</td>
						<td style="text-align: center;">
							<img src="images/part3_10.png" width="400px" />
							<figcaption>64 light rays</figcaption>
						</td>
					</tr>
				</table>
			</div>
			<h2>Part 4: Global Illumination</h2>
			1024 samples per pixel, 8 light rays, 5 light bounces
			<div style="display: flex; flex-direction: column; align-items: center;">
				<table style="width: 100%; text-align: center; border-collapse: collapse;">
					<tr>
						<td style="text-align: center;">
							<img src="images/part4_1.png" width="400px" />
							<figcaption>dae/sky/CBspheres_lambertian.dae</figcaption>
						</td>
						<td style="text-align: center;">
							<img src="images/part4_2.png" width="400px" />
							<figcaption>dae/sky/CBcoil.dae</figcaption>
						</td>
					</tr>
				</table>
			</div>

			<div style="display: flex; flex-direction: column; align-items: center;">
				<table style="width: 100%; text-align: center; border-collapse: collapse;">
					<tr>
						<td style="text-align: center;">
							<img src="images/part4_3.png" width="400px" />
							<figcaption>direct illumination only</figcaption>
						</td>
						<td style="text-align: center;">
							<img src="images/part4_3b.png" width="400px" />
							<figcaption>indirect illumination only</figcaption>
						</td>
					</tr>
				</table>
			</div>

			<div style="display: flex; flex-direction: column; align-items: center;">
				<table style="width: 100%; text-align: center; border-collapse: collapse;">
					<tr>
						<td style="text-align: center;">
							<img src="images/part4_4.png" width="150px" />
							<figcaption>m=0</figcaption>
						</td>
						<td style="text-align: center;">
							<img src="images/part4_5.png" width="150px" />
							<figcaption>m=1</figcaption>
						</td>
						<td style="text-align: center;">
							<img src="images/part4_6.png" width="125px" />
							<figcaption>m=2</figcaption>
						</td>
						<td style="text-align: center;">
							<img src="images/part4_7.png" width="125px" />
							<figcaption>m=3</figcaption>
						</td>
						<td style="text-align: center;">
							<img src="images/part4_8.png" width="125px" />
							<figcaption>m=4</figcaption>
						</td>
						<td style="text-align: center;">
							<img src="images/part4_9.png" width="125px" />
							<figcaption>m=5</figcaption>
						</td>
					</tr>
					<tr>
						<td style="text-align: center;">
							<img src="images/part4_10.png" width="125px" />
							<figcaption>m=0</figcaption>
						</td>
						<td style="text-align: center;">
							<img src="images/part4_11.png" width="125px" />
							<figcaption>m=1</figcaption>
						</td>
						<td style="text-align: center;">
							<img src="images/part4_12.png" width="125px" />
							<figcaption>m=2</figcaption>
						</td>
						<td style="text-align: center;">
							<img src="images/part4_13.png" width="125px" />
							<figcaption>m=3</figcaption>
						</td>
						<td style="text-align: center;">
							<img src="images/part4_14.png" width="125px" />
							<figcaption>m=4</figcaption>
						</td>
						<td style="text-align: center;">
							<img src="images/part4_15.png" width="150px" />
							<figcaption>m=5</figcaption>
						</td>
					</tr>
				</table>
			</div>
			0.35 russian roulette probability
			<div style="display: flex; flex-direction: column; align-items: center;">
				<table style="width: 100%; text-align: center; border-collapse: collapse;">
					<tr>
						<td style="text-align: center;">
							<img src="images/part4_16.png" width="400px" />
							<figcaption>m=0</figcaption>
						</td>
						<td style="text-align: center;">
							<img src="images/part4_17.png" width="400px" />
							<figcaption>m=1</figcaption>
						</td>
					</tr>
					<tr>
						<td style="text-align: center;">
							<img src="images/part4_18.png" width="400px" />
							<figcaption>m=2</figcaption>
						</td>
						<td style="text-align: center;">
							<img src="images/part4_19.png" width="400px" />
							<figcaption>m=3</figcaption>
						</td>
					</tr>
					<tr>
						<td style="text-align: center;">
							<img src="images/part4_20.png" width="400px" />
							<figcaption>m=4</figcaption>
						</td>
						<td style="text-align: center;">
							<img src="images/part4_21.png" width="400px" />
							<figcaption>m=100</figcaption>
						</td>
					</tr>
				</table>
			</div>
			dae/sky/wall-e.dae, russian roulette still enabled w/ 5 light bounces
			<div style="display: flex; flex-direction: column; align-items: center;">
				<table style="width: 100%; text-align: center; border-collapse: collapse;">
					<tr>
						<td style="text-align: center;">
							<img src="images/part4_22.png" width="400px" />
							<figcaption>1 sample per pixel</figcaption>
						</td>
						<td style="text-align: center;">
							<img src="images/part4_23.png" width="400px" />
							<figcaption>2 samples per pixel</figcaption>
						</td>
					</tr>
					<tr>
						<td style="text-align: center;">
							<img src="images/part4_24.png" width="400px" />
							<figcaption>4 samples per pixel</figcaption>
						</td>
						<td style="text-align: center;">
							<img src="images/part4_25.png" width="400px" />
							<figcaption>8 samples per pixel</figcaption>
						</td>
					</tr>
					<tr>
						<td style="text-align: center;">
							<img src="images/part4_26.png" width="400px" />
							<figcaption>16 samples per pixel</figcaption>
						</td>
						<td style="text-align: center;">
							<img src="images/part4_27.png" width="400px" />
							<figcaption>64 samples per pixel</figcaption>
						</td>
					</tr>
					<tr>
						<td style="text-align: center;">
							<img src="images/part4_28.png" width="400px" />
							<figcaption>256 samples per pixel</figcaption>
						</td>
						<td style="text-align: center;">
							<img src="images/part4_29.png" width="400px" />
							<figcaption>1024 samples per pixel</figcaption>
						</td>
					</tr>
				</table>
			</div>
			<h2>Part 5: Adaptive Sampling</h2>
			Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.

			<h2>(Optional) Part 6: Extra Credit Opportunities</h2>
			Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.

			<h2>Additional Notes (please remove)</h2>
			<ul>
				<li>You can also add code if you'd like as so: <code>code code code</code></li>
				<li>
					If you'd like to add math equations,
					<ul>
						<li>You can write inline equations like so: \( a^2 + b^2 = c^2 \)</li>
						<li>You can write display equations like so: \[ a^2 + b^2 = c^2 \]</li>
					</ul>
				</li>
			</ul>
		</div>
	</body>
</html>